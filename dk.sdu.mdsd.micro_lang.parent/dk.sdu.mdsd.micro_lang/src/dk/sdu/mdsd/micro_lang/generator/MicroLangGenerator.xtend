/*
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.micro_lang.generator

import com.google.common.base.CaseFormat
import com.google.inject.Inject
import dk.sdu.mdsd.micro_lang.MicroLangModelUtil
import dk.sdu.mdsd.micro_lang.microLang.Endpoint
import dk.sdu.mdsd.micro_lang.microLang.Implements
import dk.sdu.mdsd.micro_lang.microLang.Method
import dk.sdu.mdsd.micro_lang.microLang.Microservice
import dk.sdu.mdsd.micro_lang.microLang.NormalPath
import dk.sdu.mdsd.micro_lang.microLang.Operation
import dk.sdu.mdsd.micro_lang.microLang.ParameterPath
import dk.sdu.mdsd.micro_lang.microLang.Return
import dk.sdu.mdsd.micro_lang.microLang.Type
import dk.sdu.mdsd.micro_lang.microLang.TypedParameter
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static org.eclipse.emf.ecore.util.EcoreUtil.UsageCrossReferencer.find

import static extension dk.sdu.mdsd.micro_lang.generator.NameAndPackage.operator_mappedTo
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MicroLangGenerator extends AbstractGenerator {
	
	@Inject
	extension MicroLangModelUtil
	
	@Inject
	extension FileSystemAccessExtension
	
	public static val GEN_FILE_EXT = ".java"
	
	public static val GEN_INTERFACE_DIR = "microservices/"
	public static val GEN_ABSTRACT_DIR = GEN_INTERFACE_DIR + "abstr/"
	public static val GEN_PROXY_DIR = GEN_INTERFACE_DIR + "proxy/"
	public static val GEN_IMPL_DIR = "impl/"
	
	public static val RES_LIB_DIR = 'src/resources/generator/'
	
	var IFileSystemAccess2 fsa

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		this.fsa = fsa
		val microservices = resource.allContents.filter(Microservice).toList
		microservices.forEach[generateMicroservice(microservices)]
		
		fsa.generateFilesFromDir(RES_LIB_DIR)
		
		fsa.addSrcGenToClassPath
		fsa.fixJreInClassPath
	}
	
	def generateMicroservice(Microservice microservice, List<Microservice> microservices) {
		val interfaceTuple = microservice.generateFile(microservice.name.toFileName, GEN_INTERFACE_DIR, [tuple | 
			microservice.generateInterface(tuple)
		])
		
		if (!find(microservice, microservices).empty) {
			microservice.generateFile(microservice.name.toProxyName, GEN_PROXY_DIR, [tuple | 
				microservice.generateProxyClass(tuple, interfaceTuple)
			])
		}
		
		val abstractTuple = microservice.generateFile("Abstract" + interfaceTuple.name, GEN_ABSTRACT_DIR, [tuple | 
			microservice.generateAbstractClass(tuple, interfaceTuple)
		])
		
		microservice.generateFile(interfaceTuple.name + "Impl", GEN_IMPL_DIR, [tuple | 
			microservice.generateStubClass(tuple, abstractTuple)
		], [fileName, contents | 
			fsa.generateFileInSrcIfAbsent(fileName, contents)
			fsa.setFilesInSrcAsNotDerived(GEN_IMPL_DIR)
		])
	}
	
	def generateFile(Microservice microservice, String name, String dir, (NameAndPackage) => CharSequence contentGen) {
		microservice.generateFile(name, dir, contentGen, [fileName, contents | 
			fsa.generateFile(fileName, contents)
		])
	}
	
	def generateFile(Microservice microservice, String name, String dir, (NameAndPackage) => CharSequence contentGen, (String, CharSequence) => void fileGen) {
		val pkg = dir.toPackage
		val tuple = name -> pkg
		fileGen.apply(dir + name + GEN_FILE_EXT, contentGen.apply(tuple))
		return tuple
	}
	
	def toPackage(String dir) {
		dir.replaceAll("/", ".").substring(0, dir.length - 1)
	}
	
	def generateInterface(Microservice microservice, NameAndPackage interfaceTuple)'''
		«generateHeader»
		package «interfaceTuple.pkg»;
		
		public interface «interfaceTuple.name» {
			
			String HOST = "«microservice.location.host»";
			int PORT = «microservice.location.port»;
			
			«microservice.generateMethods[endpoint, operation | endpoint.generateMethodSignature(operation) + ';']»
		}
	'''
	
	def generateAbstractClass(Microservice microservice, NameAndPackage abstractTuple, NameAndPackage interfaceTuple)'''
		«generateHeader»
		package «abstractTuple.pkg»;
		
		import «interfaceTuple.pkg».«interfaceTuple.name»;
		«FOR uses : microservice.uses»
		import «interfaceTuple.pkg».«uses.name.toFileName»;
		import «GEN_PROXY_DIR.toPackage».«uses.name.toProxyName»;
		«ENDFOR»
		import lib.HttpUtil;
		import java.util.Map;
		import java.util.HashMap;
		import java.io.IOException;
		import java.net.InetSocketAddress;
		import com.sun.net.httpserver.HttpServer;
		
		public abstract class «abstractTuple.name» implements «interfaceTuple.name», Runnable {
			
			protected HttpUtil util = new HttpUtil();
			«FOR uses : microservice.uses»
			protected «uses.name.toFileName» «uses.name.toAttributeName» = new «uses.name.toProxyName»();
			«ENDFOR»
			
			@Override
			public final void run() {
				try {
					HttpServer server = HttpServer.create(new InetSocketAddress(PORT), 0);
					server.createContext("/", exchange -> {
						String path = exchange.getRequestURI().getPath();
						String method = exchange.getRequestMethod();
						System.out.println(method + " " + path);
						String body = util.getBody(exchange.getRequestBody());
						System.out.println("body: " + body);
						Map<String, Object> parameters = new HashMap<>();
						try {
							parameters = util.toMap(body);
						}
						catch (Exception e) {
							util.sendResponse(exchange, 400, "Malformed parameters in body");
							return;
						}
						System.out.println("parameters: " + parameters);
						«FOR implement : microservice.implements»
							«implement.resolve»
							«FOR inheritedEndpoint : implement.inheritedEndpoints»
								«inheritedEndpoint.generateServerMethod»
							«ENDFOR»
						«ENDFOR»
						«FOR endpoint : microservice.endpoints»
							«endpoint.generateServerMethod»
						«ENDFOR»
						«IF microservice.implements.empty && microservice.endpoints.empty»
							util.sendResponse(exchange, 404, "No paths implemented");
						«ELSE»
							else {
								util.sendResponse(exchange, 404, path + " could not be found");
							}
						«ENDIF»
					});
					server.start();
					System.out.println("Now listening on port " + PORT);
				}
				catch (IOException e) {
					e.printStackTrace();
				}
			}
		
		}
	'''
	
	def generateProxyClass(Microservice microservice, NameAndPackage proxyTuple, NameAndPackage interfaceTuple)'''
		«generateHeader»
		package «proxyTuple.pkg»;
		
		import «interfaceTuple.pkg».«interfaceTuple.name»;
		import lib.HttpUtil;
		import java.io.IOException;
		
		public class «proxyTuple.name» implements «interfaceTuple.name» {
			
			private HttpUtil util = new HttpUtil();
			
			«microservice.generateMethods[endpoint, operation | endpoint.generateProxyMethod(operation)]»
		}
	'''
	
	def generateStubClass(Microservice microservice, NameAndPackage classTuple, NameAndPackage abstractTuple)'''
		«generateHeader»
		package «classTuple.pkg»;
		
		import «abstractTuple.pkg».«abstractTuple.name»;
		
		public class «classTuple.name» extends «abstractTuple.name» {
			
			«microservice.generateMethods[endpoint, operation | endpoint.generateStubMethod(operation)]»
			public static void main(String[] args) {
				new «classTuple.name»().run();
			}
		
		}
	'''
	
	def generateMethods(Microservice microservice, (Endpoint, Operation) => CharSequence generator)'''
		«FOR implement : microservice.implements»
			«implement.resolve»
			«FOR inheritedEndpoint : implement.inheritedEndpoints»
				«FOR operation : inheritedEndpoint.operations»
					«generator.apply(inheritedEndpoint, operation)»
					
				«ENDFOR»
			«ENDFOR»
		«ENDFOR»
		«FOR endpoint : microservice.endpoints»
			«FOR operation : endpoint.operations»
				«generator.apply(endpoint, operation)»
				
			«ENDFOR»
		«ENDFOR»
	'''
	
	def generateServerMethod(Endpoint endpoint)'''
		if (path.matches("«endpoint.generateRegex»")) {
			System.out.println("«endpoint.path» was hit");
			switch (method) {
				«FOR operation : endpoint.operations»
					case "«operation.method.name»": {
						«endpoint.generateMethodInvocation(operation)»
						return;
					}
				«ENDFOR»
				default:
					util.sendResponse(exchange, 405, method + " is not implemented on " + path);
			}
		}
	'''
	
	def generateRegex(Endpoint endpoint) {
		'\\\\/' + endpoint.pathParts.map[
			switch it {
				NormalPath: name ?: ""
				ParameterPath: parameter.type.generateRegex
			}
		].join('\\\\/')
	}
	
	def generateRegex(Type type) {
		switch type.name {
			case "bool": '''(true|false)'''
			case "string": '''(?!(true|false)\\b)\\b\\w+'''
			case "int": '''\\d+'''
			case "double": '''[0-9]+(\\.[0-9]+)'''
		}
	}
	
	def generateMethodInvocation(Endpoint endpoint, Operation operation)'''
		«FOR entry : endpoint.mapParametersToIndex.entrySet»
			«entry.key.generateVariableAssignment('''path.split("/")[«entry.value»]''')»
		«ENDFOR»
		«FOR param : operation.parameters»
			«param.generateVariableAssignment('''parameters.get("«param.name»")''')»
		«ENDFOR»
		«IF operation.hasReturn»Object response = «ENDIF»«endpoint.toMethodName(operation)»«(endpoint.mapParametersToIndex.keySet + operation.parameters).generateArguments»;
		util.sendResponse(exchange, 200«IF operation.hasReturn», response«ENDIF»);
	'''
	
	def mapParametersToIndex(Endpoint endpoint) {
		endpoint.pathParts.filter(ParameterPath).toMap([parameter], [endpoint.pathParts.indexOf(it) + 1])
	}
	
	def generateTypeCast(Type type, String value)
		'''«type.generateBoxedType».valueOf(«value»)'''
	
	def generateVariableAssignment(TypedParameter param, String value)
		'''«param.type.generateType» «param.name» = «param.type.generateTypeCast(value)»;'''
	
	def generateMethodSignature(Endpoint endpoint, Operation operation)
		'''«operation.returnType.generateReturn» «endpoint.toMethodName(operation)»«endpoint.parameters(operation).generateParameters»'''
	
	def generateParameters(Iterable<TypedParameter> params)
		'''(«FOR param : params SEPARATOR ', '»«param.type.generateType» «param.name»«ENDFOR»)'''
	
	def generateArguments(Iterable<TypedParameter> params)
		'''(«FOR param : params SEPARATOR ', '»«param.name»«ENDFOR»)'''
	
	def generateReturn(Return returnType) {
		if (returnType === null) {
			return '''void'''
		}
		'''«returnType.type.generateType»'''
	}
	
	def generateType(Type type) {
		val name = switch type.name {
			case "string": "String"
			case "bool": "boolean"
			default: type.name
		}
		name + type.arrays.join
	}
	
	def generateBoxedType(Type type) {
		val name = switch type.name {
			case "int": "Integer"
			case "bool": "Boolean"
			default: type.name
		}
		name.toFirstUpper
	}
	
	def generateStubMethod(Endpoint endpoint, Operation operation)'''
		@Override
		public «endpoint.generateMethodSignature(operation)» {
			//TODO: implement endpoint logic here
			«operation.returnType.generateStubReturn»
		}
	'''
	
	def generateProxyMethod(Endpoint endpoint, Operation operation)'''
		@Override
		public «endpoint.generateMethodSignature(operation)» {
			try {
				String response = util.sendRequest("http://" + HOST + ":" + PORT + "/«endpoint.toParameterPath»", "«operation.method.name»", "«operation.paramsToBody»");
				return «operation.returnType.type.generateTypeCast('''response''')»;
			}
			catch (IOException e) {
				e.printStackTrace();
			}
			«operation.returnType.generateStubReturn»
		}
	'''
	
	def generateStubReturn(Return returnType) {
		if (returnType === null) {
			return ''''''
		}
		if (!returnType.type.arrays.empty) {
			return '''return null;'''
		}
		switch returnType.type.name {
			case "bool": '''return false;'''
			case "double", 
			case "int": '''return 0;'''
			default: '''return null;'''
		}
	}
	
	def toParameterPath(Endpoint endpoint) {
		endpoint.pathParts.map[
			switch it {
				NormalPath: name
				ParameterPath: '''" + «parameter.name» + "'''
			}
		].join('/')
	}
	
	def paramsToBody(Operation operation) {
		operation.parameters.map[
			'''«name»=" + «name» + "'''
		].join('&')
		
	}
	
	def toFileName(String name) {
		CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, name)
	}
	
	def toAttributeName(String name) {
		CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, name)
	}
	
	def toProxyName(String name) {
		name.toFileName + 'Proxy'
	}
	
	def toMethodName(Endpoint endpoint, Operation operation) {
		var pathName = endpoint.pathParts.filter(NormalPath).map[name ?: ""].join("_")
		val operationName = operation.method.name.toLowerCase
		pathName = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, pathName)
		operationName + pathName
	}
	
	def void resolve(Implements implement) {
		val args = implement.arguments
		implement.target.parameters.forEach[parameter, index | 
			find(parameter, parameter.eContainer).forEach[EObject.resolve(args.get(index))]
		]
		implement.target.implements.forEach[resolve]
	}
	
	def dispatch resolve(NormalPath path, String arg) {
		path.name = arg
	}
	
	def dispatch resolve(Method method, String arg) {
		method.name = arg
	}
	
	def dispatch resolve(TypedParameter parameter, String arg) {
		parameter.name = arg
	}
	
	def dispatch resolve(Type type, String arg) {
		type.name = arg
	}
	
	def generateHeader()'''
		/**
		 * Generated by MicroLang
		 */
 	'''
	
}
